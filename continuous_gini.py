"""Implementation of the mathematical formulation of the Gini impurity Index 
that computes the Gini impurity index for continuous variables. """
import numpy as np

def continuous_gini(X, y, varIdx):
    """Provide a simple function implementing the mathematical formulation for 
    identifying both the optimal Gini impurity index and the threshold for optimality of a continuous variable.
    Returns:
        best_gini: Gini of the feature for best split, or None if no split is found.
        best_thr: Threshold to use for the split, or None if no split is found.
    Calculate the gini impurity index of continuous variables with respect to
    the outcome variable. Only appropriate for binary outcomes"""
    n_classes_ = len(set(y))  # classes are assumed to go from 0 to n-1
    n_features_ = X.shape[1]

    """Convert outcome vector to desired format"""
    # change class type to integers 0 to n-1
    distinct_classes = np.unique(y)
    for i in range(n_classes_):
        y = np.where(y == distinct_classes[i], i,y)

    """ Change categories to one-hot encoding values, create dummy variables
    only works for categories with type str and two levels """
    for i in range(n_features_):
        var = X[:,i]
        if type(var[1]) == str: # cat must be type str
            cats = np.unique(var)
            if len(cats) == 2: # cat must be two levels
                X[:,i] = np.where(var == cats[1],0,1)
    
    """Find the best split for a node.
    "Best" means that the average impurity of the two children, weighted by their
    population, is the smallest possible. 
    To find the best split, we loop through all the features, and consider all the
    midpoints between adjacent training samples as possible thresholds. We compute
    the Gini impurity of the split generated by that particular feature/threshold
    pair, and return the pair with smallest impurity.
    """
    # Need at least two elements to split a node.
    m = y.size
    if m <= 1:
        return None, None

    # Count of each class in the current node.
    num_parent = [np.sum(y == c) for c in range(n_classes_)]

    # Gini of current node.
    best_gini = 1.0 - sum((n / m) ** 2 for n in num_parent)
    best_idx, best_thr = None, None

    # Sort data along selected feature.
    thresholds, classes = zip(*sorted(zip(X[:, varIdx], y)))

    # We could actually split the node according to each feature/threshold pair
    # and count the resulting population for each class in the children, but
    # instead we compute them in an iterative fashion, making this for loop
    # linear rather than quadratic.
    num_left = [0] * n_classes_
    num_right = num_parent.copy()
    for i in range(1, m):  # possible split positions
        c = classes[i - 1]
        num_left[c] += 1
        num_right[c] -= 1
        gini_left = 1.0 - sum(
            (num_left[x] / i) ** 2 for x in range(n_classes_)
        )
        gini_right = 1.0 - sum(
            (num_right[x] / (m - i)) ** 2 for x in range(n_classes_)
        )

        # The Gini impurity of a split is the weighted average of the Gini
        # impurity of the children.
        gini = (i * gini_left + (m - i) * gini_right) / m

        # The following condition is to make sure we don't try to split two
        # points with identical values for that feature, as it is impossible
        # (both have to end up on the same side of a split).
        if thresholds[i] == thresholds[i - 1]:
            continue

        if gini < best_gini:
            best_gini = gini
            best_thr = (thresholds[i] + thresholds[i - 1]) / 2  # midpoint

    return best_gini, best_thr

# default run on cmd
if __name__ == "__main__": 
    import numpy as np
    import pandas as pd
    df = pd.read_csv('~/ExampleData.csv')
    arr = df.to_numpy()
    
    # predictors
    X = arr[:,1:]
    
    # outcome
    y = arr[:,0]
    
    # index of variable to calculate
    TimeIdx = 3       # idx is 3 for Time
    AgeIdx = 0       # idx is 0 for Age
    OverallHealthIdx = 2 # idx is 2 for overallhealthidx

    print("Age (Gini,Threshold): " + str(continuous_gini(X,y,AgeIdx)))
    print("OverallHealthIdx (Gini,Threshold): " + str(continuous_gini(X,y,OverallHealthIdx)))
    print("Time (Gini,Threshold): " + str(continuous_gini(X,y,TimeIdx)))
